// Generated by jextract

package net.codecrete.usb.macos.gen.corefoundation;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class CoreFoundation extends CoreFoundation$shared {

    CoreFoundation() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup("/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation", LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());


    private static class CFGetTypeID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            CoreFoundation.C_LONG,
            CoreFoundation.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("CFGetTypeID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern CFTypeID CFGetTypeID(CFTypeRef cf)
     * }
     */
    public static FunctionDescriptor CFGetTypeID$descriptor() {
        return CFGetTypeID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern CFTypeID CFGetTypeID(CFTypeRef cf)
     * }
     */
    public static MethodHandle CFGetTypeID$handle() {
        return CFGetTypeID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern CFTypeID CFGetTypeID(CFTypeRef cf)
     * }
     */
    public static MemorySegment CFGetTypeID$address() {
        return CFGetTypeID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern CFTypeID CFGetTypeID(CFTypeRef cf)
     * }
     */
    public static long CFGetTypeID(MemorySegment cf) {
        var mh$ = CFGetTypeID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CFGetTypeID", cf);
            }
            return (long)mh$.invokeExact(cf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CFRelease {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            CoreFoundation.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("CFRelease");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void CFRelease(CFTypeRef cf)
     * }
     */
    public static FunctionDescriptor CFRelease$descriptor() {
        return CFRelease.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void CFRelease(CFTypeRef cf)
     * }
     */
    public static MethodHandle CFRelease$handle() {
        return CFRelease.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void CFRelease(CFTypeRef cf)
     * }
     */
    public static MemorySegment CFRelease$address() {
        return CFRelease.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void CFRelease(CFTypeRef cf)
     * }
     */
    public static void CFRelease(MemorySegment cf) {
        var mh$ = CFRelease.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CFRelease", cf);
            }
            mh$.invokeExact(cf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CFDataCreate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            CoreFoundation.C_POINTER,
            CoreFoundation.C_POINTER,
            CoreFoundation.C_POINTER,
            CoreFoundation.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("CFDataCreate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
     * }
     */
    public static FunctionDescriptor CFDataCreate$descriptor() {
        return CFDataCreate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
     * }
     */
    public static MethodHandle CFDataCreate$handle() {
        return CFDataCreate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
     * }
     */
    public static MemorySegment CFDataCreate$address() {
        return CFDataCreate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
     * }
     */
    public static MemorySegment CFDataCreate(MemorySegment allocator, MemorySegment bytes, long length) {
        var mh$ = CFDataCreate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CFDataCreate", allocator, bytes, length);
            }
            return (MemorySegment)mh$.invokeExact(allocator, bytes, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CFDataGetBytePtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            CoreFoundation.C_POINTER,
            CoreFoundation.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("CFDataGetBytePtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const UInt8 *CFDataGetBytePtr(CFDataRef theData)
     * }
     */
    public static FunctionDescriptor CFDataGetBytePtr$descriptor() {
        return CFDataGetBytePtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const UInt8 *CFDataGetBytePtr(CFDataRef theData)
     * }
     */
    public static MethodHandle CFDataGetBytePtr$handle() {
        return CFDataGetBytePtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const UInt8 *CFDataGetBytePtr(CFDataRef theData)
     * }
     */
    public static MemorySegment CFDataGetBytePtr$address() {
        return CFDataGetBytePtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const UInt8 *CFDataGetBytePtr(CFDataRef theData)
     * }
     */
    public static MemorySegment CFDataGetBytePtr(MemorySegment theData) {
        var mh$ = CFDataGetBytePtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CFDataGetBytePtr", theData);
            }
            return (MemorySegment)mh$.invokeExact(theData);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CFStringGetTypeID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            CoreFoundation.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("CFStringGetTypeID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern CFTypeID CFStringGetTypeID(void)
     * }
     */
    public static FunctionDescriptor CFStringGetTypeID$descriptor() {
        return CFStringGetTypeID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern CFTypeID CFStringGetTypeID(void)
     * }
     */
    public static MethodHandle CFStringGetTypeID$handle() {
        return CFStringGetTypeID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern CFTypeID CFStringGetTypeID(void)
     * }
     */
    public static MemorySegment CFStringGetTypeID$address() {
        return CFStringGetTypeID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern CFTypeID CFStringGetTypeID(void)
     * }
     */
    public static long CFStringGetTypeID() {
        var mh$ = CFStringGetTypeID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CFStringGetTypeID");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CFStringCreateWithCharacters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            CoreFoundation.C_POINTER,
            CoreFoundation.C_POINTER,
            CoreFoundation.C_POINTER,
            CoreFoundation.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("CFStringCreateWithCharacters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern CFStringRef CFStringCreateWithCharacters(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars)
     * }
     */
    public static FunctionDescriptor CFStringCreateWithCharacters$descriptor() {
        return CFStringCreateWithCharacters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern CFStringRef CFStringCreateWithCharacters(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars)
     * }
     */
    public static MethodHandle CFStringCreateWithCharacters$handle() {
        return CFStringCreateWithCharacters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern CFStringRef CFStringCreateWithCharacters(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars)
     * }
     */
    public static MemorySegment CFStringCreateWithCharacters$address() {
        return CFStringCreateWithCharacters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern CFStringRef CFStringCreateWithCharacters(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars)
     * }
     */
    public static MemorySegment CFStringCreateWithCharacters(MemorySegment alloc, MemorySegment chars, long numChars) {
        var mh$ = CFStringCreateWithCharacters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CFStringCreateWithCharacters", alloc, chars, numChars);
            }
            return (MemorySegment)mh$.invokeExact(alloc, chars, numChars);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CFStringGetLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            CoreFoundation.C_LONG,
            CoreFoundation.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("CFStringGetLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern CFIndex CFStringGetLength(CFStringRef theString)
     * }
     */
    public static FunctionDescriptor CFStringGetLength$descriptor() {
        return CFStringGetLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern CFIndex CFStringGetLength(CFStringRef theString)
     * }
     */
    public static MethodHandle CFStringGetLength$handle() {
        return CFStringGetLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern CFIndex CFStringGetLength(CFStringRef theString)
     * }
     */
    public static MemorySegment CFStringGetLength$address() {
        return CFStringGetLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern CFIndex CFStringGetLength(CFStringRef theString)
     * }
     */
    public static long CFStringGetLength(MemorySegment theString) {
        var mh$ = CFStringGetLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CFStringGetLength", theString);
            }
            return (long)mh$.invokeExact(theString);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CFStringGetCharacters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            CoreFoundation.C_POINTER,
            CFRange.layout(),
            CoreFoundation.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("CFStringGetCharacters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
     * }
     */
    public static FunctionDescriptor CFStringGetCharacters$descriptor() {
        return CFStringGetCharacters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
     * }
     */
    public static MethodHandle CFStringGetCharacters$handle() {
        return CFStringGetCharacters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
     * }
     */
    public static MemorySegment CFStringGetCharacters$address() {
        return CFStringGetCharacters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
     * }
     */
    public static void CFStringGetCharacters(MemorySegment theString, MemorySegment range, MemorySegment buffer) {
        var mh$ = CFStringGetCharacters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CFStringGetCharacters", theString, range, buffer);
            }
            mh$.invokeExact(theString, range, buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int kCFNumberSInt32Type = (int)3L;
    /**
     * {@snippet lang=c :
     * enum enum (unnamed at /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/CoreFoundation.framework/Headers/CFNumber.h:31:9).kCFNumberSInt32Type = 3
     * }
     */
    public static int kCFNumberSInt32Type() {
        return kCFNumberSInt32Type;
    }

    private static class CFNumberGetTypeID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            CoreFoundation.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("CFNumberGetTypeID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern CFTypeID CFNumberGetTypeID(void)
     * }
     */
    public static FunctionDescriptor CFNumberGetTypeID$descriptor() {
        return CFNumberGetTypeID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern CFTypeID CFNumberGetTypeID(void)
     * }
     */
    public static MethodHandle CFNumberGetTypeID$handle() {
        return CFNumberGetTypeID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern CFTypeID CFNumberGetTypeID(void)
     * }
     */
    public static MemorySegment CFNumberGetTypeID$address() {
        return CFNumberGetTypeID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern CFTypeID CFNumberGetTypeID(void)
     * }
     */
    public static long CFNumberGetTypeID() {
        var mh$ = CFNumberGetTypeID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CFNumberGetTypeID");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CFNumberGetValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            CoreFoundation.C_CHAR,
            CoreFoundation.C_POINTER,
            CoreFoundation.C_LONG,
            CoreFoundation.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("CFNumberGetValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
     * }
     */
    public static FunctionDescriptor CFNumberGetValue$descriptor() {
        return CFNumberGetValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
     * }
     */
    public static MethodHandle CFNumberGetValue$handle() {
        return CFNumberGetValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
     * }
     */
    public static MemorySegment CFNumberGetValue$address() {
        return CFNumberGetValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
     * }
     */
    public static byte CFNumberGetValue(MemorySegment number, long theType, MemorySegment valuePtr) {
        var mh$ = CFNumberGetValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CFNumberGetValue", number, theType, valuePtr);
            }
            return (byte)mh$.invokeExact(number, theType, valuePtr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CFRunLoopGetCurrent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            CoreFoundation.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("CFRunLoopGetCurrent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern CFRunLoopRef CFRunLoopGetCurrent(void)
     * }
     */
    public static FunctionDescriptor CFRunLoopGetCurrent$descriptor() {
        return CFRunLoopGetCurrent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern CFRunLoopRef CFRunLoopGetCurrent(void)
     * }
     */
    public static MethodHandle CFRunLoopGetCurrent$handle() {
        return CFRunLoopGetCurrent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern CFRunLoopRef CFRunLoopGetCurrent(void)
     * }
     */
    public static MemorySegment CFRunLoopGetCurrent$address() {
        return CFRunLoopGetCurrent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern CFRunLoopRef CFRunLoopGetCurrent(void)
     * }
     */
    public static MemorySegment CFRunLoopGetCurrent() {
        var mh$ = CFRunLoopGetCurrent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CFRunLoopGetCurrent");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CFRunLoopRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("CFRunLoopRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void CFRunLoopRun(void)
     * }
     */
    public static FunctionDescriptor CFRunLoopRun$descriptor() {
        return CFRunLoopRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void CFRunLoopRun(void)
     * }
     */
    public static MethodHandle CFRunLoopRun$handle() {
        return CFRunLoopRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void CFRunLoopRun(void)
     * }
     */
    public static MemorySegment CFRunLoopRun$address() {
        return CFRunLoopRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void CFRunLoopRun(void)
     * }
     */
    public static void CFRunLoopRun() {
        var mh$ = CFRunLoopRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CFRunLoopRun");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CFRunLoopAddSource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            CoreFoundation.C_POINTER,
            CoreFoundation.C_POINTER,
            CoreFoundation.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("CFRunLoopAddSource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
     * }
     */
    public static FunctionDescriptor CFRunLoopAddSource$descriptor() {
        return CFRunLoopAddSource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
     * }
     */
    public static MethodHandle CFRunLoopAddSource$handle() {
        return CFRunLoopAddSource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
     * }
     */
    public static MemorySegment CFRunLoopAddSource$address() {
        return CFRunLoopAddSource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
     * }
     */
    public static void CFRunLoopAddSource(MemorySegment rl, MemorySegment source, MemorySegment mode) {
        var mh$ = CFRunLoopAddSource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CFRunLoopAddSource", rl, source, mode);
            }
            mh$.invokeExact(rl, source, mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CFRunLoopRemoveSource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            CoreFoundation.C_POINTER,
            CoreFoundation.C_POINTER,
            CoreFoundation.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("CFRunLoopRemoveSource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
     * }
     */
    public static FunctionDescriptor CFRunLoopRemoveSource$descriptor() {
        return CFRunLoopRemoveSource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
     * }
     */
    public static MethodHandle CFRunLoopRemoveSource$handle() {
        return CFRunLoopRemoveSource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
     * }
     */
    public static MemorySegment CFRunLoopRemoveSource$address() {
        return CFRunLoopRemoveSource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
     * }
     */
    public static void CFRunLoopRemoveSource(MemorySegment rl, MemorySegment source, MemorySegment mode) {
        var mh$ = CFRunLoopRemoveSource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CFRunLoopRemoveSource", rl, source, mode);
            }
            mh$.invokeExact(rl, source, mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CFUUIDGetUUIDBytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            CFUUIDBytes.layout(),
            CoreFoundation.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("CFUUIDGetUUIDBytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
     * }
     */
    public static FunctionDescriptor CFUUIDGetUUIDBytes$descriptor() {
        return CFUUIDGetUUIDBytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
     * }
     */
    public static MethodHandle CFUUIDGetUUIDBytes$handle() {
        return CFUUIDGetUUIDBytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
     * }
     */
    public static MemorySegment CFUUIDGetUUIDBytes$address() {
        return CFUUIDGetUUIDBytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
     * }
     */
    public static MemorySegment CFUUIDGetUUIDBytes(SegmentAllocator allocator, MemorySegment uuid) {
        var mh$ = CFUUIDGetUUIDBytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CFUUIDGetUUIDBytes", allocator, uuid);
            }
            return (MemorySegment)mh$.invokeExact(allocator, uuid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CFUUIDCreateFromUUIDBytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            CoreFoundation.C_POINTER,
            CoreFoundation.C_POINTER,
            CFUUIDBytes.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("CFUUIDCreateFromUUIDBytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
     * }
     */
    public static FunctionDescriptor CFUUIDCreateFromUUIDBytes$descriptor() {
        return CFUUIDCreateFromUUIDBytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
     * }
     */
    public static MethodHandle CFUUIDCreateFromUUIDBytes$handle() {
        return CFUUIDCreateFromUUIDBytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
     * }
     */
    public static MemorySegment CFUUIDCreateFromUUIDBytes$address() {
        return CFUUIDCreateFromUUIDBytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
     * }
     */
    public static MemorySegment CFUUIDCreateFromUUIDBytes(MemorySegment alloc, MemorySegment bytes) {
        var mh$ = CFUUIDCreateFromUUIDBytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CFUUIDCreateFromUUIDBytes", alloc, bytes);
            }
            return (MemorySegment)mh$.invokeExact(alloc, bytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CFMessagePortCreateLocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            CoreFoundation.C_POINTER,
            CoreFoundation.C_POINTER,
            CoreFoundation.C_POINTER,
            CoreFoundation.C_POINTER,
            CoreFoundation.C_POINTER,
            CoreFoundation.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("CFMessagePortCreateLocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern CFMessagePortRef CFMessagePortCreateLocal(CFAllocatorRef allocator, CFStringRef name, CFMessagePortCallBack callout, CFMessagePortContext *context, Boolean *shouldFreeInfo)
     * }
     */
    public static FunctionDescriptor CFMessagePortCreateLocal$descriptor() {
        return CFMessagePortCreateLocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern CFMessagePortRef CFMessagePortCreateLocal(CFAllocatorRef allocator, CFStringRef name, CFMessagePortCallBack callout, CFMessagePortContext *context, Boolean *shouldFreeInfo)
     * }
     */
    public static MethodHandle CFMessagePortCreateLocal$handle() {
        return CFMessagePortCreateLocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern CFMessagePortRef CFMessagePortCreateLocal(CFAllocatorRef allocator, CFStringRef name, CFMessagePortCallBack callout, CFMessagePortContext *context, Boolean *shouldFreeInfo)
     * }
     */
    public static MemorySegment CFMessagePortCreateLocal$address() {
        return CFMessagePortCreateLocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern CFMessagePortRef CFMessagePortCreateLocal(CFAllocatorRef allocator, CFStringRef name, CFMessagePortCallBack callout, CFMessagePortContext *context, Boolean *shouldFreeInfo)
     * }
     */
    public static MemorySegment CFMessagePortCreateLocal(MemorySegment allocator, MemorySegment name, MemorySegment callout, MemorySegment context, MemorySegment shouldFreeInfo) {
        var mh$ = CFMessagePortCreateLocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CFMessagePortCreateLocal", allocator, name, callout, context, shouldFreeInfo);
            }
            return (MemorySegment)mh$.invokeExact(allocator, name, callout, context, shouldFreeInfo);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CFMessagePortCreateRemote {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            CoreFoundation.C_POINTER,
            CoreFoundation.C_POINTER,
            CoreFoundation.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("CFMessagePortCreateRemote");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern CFMessagePortRef CFMessagePortCreateRemote(CFAllocatorRef allocator, CFStringRef name)
     * }
     */
    public static FunctionDescriptor CFMessagePortCreateRemote$descriptor() {
        return CFMessagePortCreateRemote.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern CFMessagePortRef CFMessagePortCreateRemote(CFAllocatorRef allocator, CFStringRef name)
     * }
     */
    public static MethodHandle CFMessagePortCreateRemote$handle() {
        return CFMessagePortCreateRemote.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern CFMessagePortRef CFMessagePortCreateRemote(CFAllocatorRef allocator, CFStringRef name)
     * }
     */
    public static MemorySegment CFMessagePortCreateRemote$address() {
        return CFMessagePortCreateRemote.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern CFMessagePortRef CFMessagePortCreateRemote(CFAllocatorRef allocator, CFStringRef name)
     * }
     */
    public static MemorySegment CFMessagePortCreateRemote(MemorySegment allocator, MemorySegment name) {
        var mh$ = CFMessagePortCreateRemote.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CFMessagePortCreateRemote", allocator, name);
            }
            return (MemorySegment)mh$.invokeExact(allocator, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CFMessagePortSendRequest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            CoreFoundation.C_INT,
            CoreFoundation.C_POINTER,
            CoreFoundation.C_INT,
            CoreFoundation.C_POINTER,
            CoreFoundation.C_DOUBLE,
            CoreFoundation.C_DOUBLE,
            CoreFoundation.C_POINTER,
            CoreFoundation.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("CFMessagePortSendRequest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern SInt32 CFMessagePortSendRequest(CFMessagePortRef remote, SInt32 msgid, CFDataRef data, CFTimeInterval sendTimeout, CFTimeInterval rcvTimeout, CFStringRef replyMode, CFDataRef *returnData)
     * }
     */
    public static FunctionDescriptor CFMessagePortSendRequest$descriptor() {
        return CFMessagePortSendRequest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern SInt32 CFMessagePortSendRequest(CFMessagePortRef remote, SInt32 msgid, CFDataRef data, CFTimeInterval sendTimeout, CFTimeInterval rcvTimeout, CFStringRef replyMode, CFDataRef *returnData)
     * }
     */
    public static MethodHandle CFMessagePortSendRequest$handle() {
        return CFMessagePortSendRequest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern SInt32 CFMessagePortSendRequest(CFMessagePortRef remote, SInt32 msgid, CFDataRef data, CFTimeInterval sendTimeout, CFTimeInterval rcvTimeout, CFStringRef replyMode, CFDataRef *returnData)
     * }
     */
    public static MemorySegment CFMessagePortSendRequest$address() {
        return CFMessagePortSendRequest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern SInt32 CFMessagePortSendRequest(CFMessagePortRef remote, SInt32 msgid, CFDataRef data, CFTimeInterval sendTimeout, CFTimeInterval rcvTimeout, CFStringRef replyMode, CFDataRef *returnData)
     * }
     */
    public static int CFMessagePortSendRequest(MemorySegment remote, int msgid, MemorySegment data, double sendTimeout, double rcvTimeout, MemorySegment replyMode, MemorySegment returnData) {
        var mh$ = CFMessagePortSendRequest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CFMessagePortSendRequest", remote, msgid, data, sendTimeout, rcvTimeout, replyMode, returnData);
            }
            return (int)mh$.invokeExact(remote, msgid, data, sendTimeout, rcvTimeout, replyMode, returnData);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CFMessagePortCreateRunLoopSource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            CoreFoundation.C_POINTER,
            CoreFoundation.C_POINTER,
            CoreFoundation.C_POINTER,
            CoreFoundation.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("CFMessagePortCreateRunLoopSource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern CFRunLoopSourceRef CFMessagePortCreateRunLoopSource(CFAllocatorRef allocator, CFMessagePortRef local, CFIndex order)
     * }
     */
    public static FunctionDescriptor CFMessagePortCreateRunLoopSource$descriptor() {
        return CFMessagePortCreateRunLoopSource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern CFRunLoopSourceRef CFMessagePortCreateRunLoopSource(CFAllocatorRef allocator, CFMessagePortRef local, CFIndex order)
     * }
     */
    public static MethodHandle CFMessagePortCreateRunLoopSource$handle() {
        return CFMessagePortCreateRunLoopSource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern CFRunLoopSourceRef CFMessagePortCreateRunLoopSource(CFAllocatorRef allocator, CFMessagePortRef local, CFIndex order)
     * }
     */
    public static MemorySegment CFMessagePortCreateRunLoopSource$address() {
        return CFMessagePortCreateRunLoopSource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern CFRunLoopSourceRef CFMessagePortCreateRunLoopSource(CFAllocatorRef allocator, CFMessagePortRef local, CFIndex order)
     * }
     */
    public static MemorySegment CFMessagePortCreateRunLoopSource(MemorySegment allocator, MemorySegment local, long order) {
        var mh$ = CFMessagePortCreateRunLoopSource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CFMessagePortCreateRunLoopSource", allocator, local, order);
            }
            return (MemorySegment)mh$.invokeExact(allocator, local, order);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

