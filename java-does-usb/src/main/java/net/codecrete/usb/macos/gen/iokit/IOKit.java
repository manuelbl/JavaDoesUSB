// Generated by jextract

package net.codecrete.usb.macos.gen.iokit;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class IOKit extends IOKit$shared {

    IOKit() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup("/System/Library/Frameworks/IOKit.framework/IOKit", LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    private static final int kIOUSBFindInterfaceDontCare = (int)65535L;
    /**
     * {@snippet lang=c :
     * enum enum (unnamed at /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/IOKit.framework/Headers/usb/USB.h:898:1).kIOUSBFindInterfaceDontCare = 65535
     * }
     */
    public static int kIOUSBFindInterfaceDontCare() {
        return kIOUSBFindInterfaceDontCare;
    }
    private static final int kUSBReEnumerateCaptureDeviceMask = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * enum USBReEnumerateOptions.kUSBReEnumerateCaptureDeviceMask = 1073741824
     * }
     */
    public static int kUSBReEnumerateCaptureDeviceMask() {
        return kUSBReEnumerateCaptureDeviceMask;
    }
    private static final int kUSBReEnumerateReleaseDeviceMask = (int)536870912L;
    /**
     * {@snippet lang=c :
     * enum USBReEnumerateOptions.kUSBReEnumerateReleaseDeviceMask = 536870912
     * }
     */
    public static int kUSBReEnumerateReleaseDeviceMask() {
        return kUSBReEnumerateReleaseDeviceMask;
    }

    private static class kCFRunLoopDefaultMode$constants {
        public static final AddressLayout LAYOUT = IOKit.C_POINTER;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("kCFRunLoopDefaultMode").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const CFRunLoopMode kCFRunLoopDefaultMode
     * }
     */
    public static AddressLayout kCFRunLoopDefaultMode$layout() {
        return kCFRunLoopDefaultMode$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const CFRunLoopMode kCFRunLoopDefaultMode
     * }
     */
    public static MemorySegment kCFRunLoopDefaultMode$segment() {
        return kCFRunLoopDefaultMode$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const CFRunLoopMode kCFRunLoopDefaultMode
     * }
     */
    public static MemorySegment kCFRunLoopDefaultMode() {
        return kCFRunLoopDefaultMode$constants.SEGMENT.get(kCFRunLoopDefaultMode$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const CFRunLoopMode kCFRunLoopDefaultMode
     * }
     */
    public static void kCFRunLoopDefaultMode(MemorySegment varValue) {
        kCFRunLoopDefaultMode$constants.SEGMENT.set(kCFRunLoopDefaultMode$constants.LAYOUT, 0L, varValue);
    }

    private static class kIOMasterPortDefault$constants {
        public static final OfInt LAYOUT = IOKit.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("kIOMasterPortDefault").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const mach_port_t kIOMasterPortDefault
     * }
     */
    public static OfInt kIOMasterPortDefault$layout() {
        return kIOMasterPortDefault$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const mach_port_t kIOMasterPortDefault
     * }
     */
    public static MemorySegment kIOMasterPortDefault$segment() {
        return kIOMasterPortDefault$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const mach_port_t kIOMasterPortDefault
     * }
     */
    public static int kIOMasterPortDefault() {
        return kIOMasterPortDefault$constants.SEGMENT.get(kIOMasterPortDefault$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const mach_port_t kIOMasterPortDefault
     * }
     */
    public static void kIOMasterPortDefault(int varValue) {
        kIOMasterPortDefault$constants.SEGMENT.set(kIOMasterPortDefault$constants.LAYOUT, 0L, varValue);
    }

    private static class IONotificationPortCreate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            IOKit.C_POINTER,
            IOKit.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("IONotificationPortCreate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
     * }
     */
    public static FunctionDescriptor IONotificationPortCreate$descriptor() {
        return IONotificationPortCreate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
     * }
     */
    public static MethodHandle IONotificationPortCreate$handle() {
        return IONotificationPortCreate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
     * }
     */
    public static MemorySegment IONotificationPortCreate$address() {
        return IONotificationPortCreate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
     * }
     */
    public static MemorySegment IONotificationPortCreate(int mainPort) {
        var mh$ = IONotificationPortCreate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IONotificationPortCreate", mainPort);
            }
            return (MemorySegment)mh$.invokeExact(mainPort);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IONotificationPortGetRunLoopSource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            IOKit.C_POINTER,
            IOKit.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("IONotificationPortGetRunLoopSource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * CFRunLoopSourceRef IONotificationPortGetRunLoopSource(IONotificationPortRef notify)
     * }
     */
    public static FunctionDescriptor IONotificationPortGetRunLoopSource$descriptor() {
        return IONotificationPortGetRunLoopSource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * CFRunLoopSourceRef IONotificationPortGetRunLoopSource(IONotificationPortRef notify)
     * }
     */
    public static MethodHandle IONotificationPortGetRunLoopSource$handle() {
        return IONotificationPortGetRunLoopSource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * CFRunLoopSourceRef IONotificationPortGetRunLoopSource(IONotificationPortRef notify)
     * }
     */
    public static MemorySegment IONotificationPortGetRunLoopSource$address() {
        return IONotificationPortGetRunLoopSource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * CFRunLoopSourceRef IONotificationPortGetRunLoopSource(IONotificationPortRef notify)
     * }
     */
    public static MemorySegment IONotificationPortGetRunLoopSource(MemorySegment notify) {
        var mh$ = IONotificationPortGetRunLoopSource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IONotificationPortGetRunLoopSource", notify);
            }
            return (MemorySegment)mh$.invokeExact(notify);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IOObjectRelease {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            IOKit.C_INT,
            IOKit.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("IOObjectRelease");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * kern_return_t IOObjectRelease(io_object_t object)
     * }
     */
    public static FunctionDescriptor IOObjectRelease$descriptor() {
        return IOObjectRelease.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * kern_return_t IOObjectRelease(io_object_t object)
     * }
     */
    public static MethodHandle IOObjectRelease$handle() {
        return IOObjectRelease.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * kern_return_t IOObjectRelease(io_object_t object)
     * }
     */
    public static MemorySegment IOObjectRelease$address() {
        return IOObjectRelease.ADDR;
    }

    /**
     * {@snippet lang=c :
     * kern_return_t IOObjectRelease(io_object_t object)
     * }
     */
    public static int IOObjectRelease(int object) {
        var mh$ = IOObjectRelease.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IOObjectRelease", object);
            }
            return (int)mh$.invokeExact(object);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IOIteratorNext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            IOKit.C_INT,
            IOKit.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("IOIteratorNext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * io_object_t IOIteratorNext(io_iterator_t iterator)
     * }
     */
    public static FunctionDescriptor IOIteratorNext$descriptor() {
        return IOIteratorNext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * io_object_t IOIteratorNext(io_iterator_t iterator)
     * }
     */
    public static MethodHandle IOIteratorNext$handle() {
        return IOIteratorNext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * io_object_t IOIteratorNext(io_iterator_t iterator)
     * }
     */
    public static MemorySegment IOIteratorNext$address() {
        return IOIteratorNext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * io_object_t IOIteratorNext(io_iterator_t iterator)
     * }
     */
    public static int IOIteratorNext(int iterator) {
        var mh$ = IOIteratorNext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IOIteratorNext", iterator);
            }
            return (int)mh$.invokeExact(iterator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IOServiceAddMatchingNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            IOKit.C_INT,
            IOKit.C_POINTER,
            IOKit.C_POINTER,
            IOKit.C_POINTER,
            IOKit.C_POINTER,
            IOKit.C_POINTER,
            IOKit.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("IOServiceAddMatchingNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * kern_return_t IOServiceAddMatchingNotification(IONotificationPortRef notifyPort, const io_name_t notificationType, CFDictionaryRef matching, IOServiceMatchingCallback callback, void *refCon, io_iterator_t *notification)
     * }
     */
    public static FunctionDescriptor IOServiceAddMatchingNotification$descriptor() {
        return IOServiceAddMatchingNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * kern_return_t IOServiceAddMatchingNotification(IONotificationPortRef notifyPort, const io_name_t notificationType, CFDictionaryRef matching, IOServiceMatchingCallback callback, void *refCon, io_iterator_t *notification)
     * }
     */
    public static MethodHandle IOServiceAddMatchingNotification$handle() {
        return IOServiceAddMatchingNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * kern_return_t IOServiceAddMatchingNotification(IONotificationPortRef notifyPort, const io_name_t notificationType, CFDictionaryRef matching, IOServiceMatchingCallback callback, void *refCon, io_iterator_t *notification)
     * }
     */
    public static MemorySegment IOServiceAddMatchingNotification$address() {
        return IOServiceAddMatchingNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * kern_return_t IOServiceAddMatchingNotification(IONotificationPortRef notifyPort, const io_name_t notificationType, CFDictionaryRef matching, IOServiceMatchingCallback callback, void *refCon, io_iterator_t *notification)
     * }
     */
    public static int IOServiceAddMatchingNotification(MemorySegment notifyPort, MemorySegment notificationType, MemorySegment matching, MemorySegment callback, MemorySegment refCon, MemorySegment notification) {
        var mh$ = IOServiceAddMatchingNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IOServiceAddMatchingNotification", notifyPort, notificationType, matching, callback, refCon, notification);
            }
            return (int)mh$.invokeExact(notifyPort, notificationType, matching, callback, refCon, notification);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IORegistryEntryGetRegistryEntryID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            IOKit.C_INT,
            IOKit.C_INT,
            IOKit.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("IORegistryEntryGetRegistryEntryID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * kern_return_t IORegistryEntryGetRegistryEntryID(io_registry_entry_t entry, uint64_t *entryID)
     * }
     */
    public static FunctionDescriptor IORegistryEntryGetRegistryEntryID$descriptor() {
        return IORegistryEntryGetRegistryEntryID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * kern_return_t IORegistryEntryGetRegistryEntryID(io_registry_entry_t entry, uint64_t *entryID)
     * }
     */
    public static MethodHandle IORegistryEntryGetRegistryEntryID$handle() {
        return IORegistryEntryGetRegistryEntryID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * kern_return_t IORegistryEntryGetRegistryEntryID(io_registry_entry_t entry, uint64_t *entryID)
     * }
     */
    public static MemorySegment IORegistryEntryGetRegistryEntryID$address() {
        return IORegistryEntryGetRegistryEntryID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * kern_return_t IORegistryEntryGetRegistryEntryID(io_registry_entry_t entry, uint64_t *entryID)
     * }
     */
    public static int IORegistryEntryGetRegistryEntryID(int entry, MemorySegment entryID) {
        var mh$ = IORegistryEntryGetRegistryEntryID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IORegistryEntryGetRegistryEntryID", entry, entryID);
            }
            return (int)mh$.invokeExact(entry, entryID);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IORegistryEntryCreateCFProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            IOKit.C_POINTER,
            IOKit.C_INT,
            IOKit.C_POINTER,
            IOKit.C_POINTER,
            IOKit.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("IORegistryEntryCreateCFProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
     * }
     */
    public static FunctionDescriptor IORegistryEntryCreateCFProperty$descriptor() {
        return IORegistryEntryCreateCFProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
     * }
     */
    public static MethodHandle IORegistryEntryCreateCFProperty$handle() {
        return IORegistryEntryCreateCFProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
     * }
     */
    public static MemorySegment IORegistryEntryCreateCFProperty$address() {
        return IORegistryEntryCreateCFProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
     * }
     */
    public static MemorySegment IORegistryEntryCreateCFProperty(int entry, MemorySegment key, MemorySegment allocator, int options) {
        var mh$ = IORegistryEntryCreateCFProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IORegistryEntryCreateCFProperty", entry, key, allocator, options);
            }
            return (MemorySegment)mh$.invokeExact(entry, key, allocator, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IOServiceMatching {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            IOKit.C_POINTER,
            IOKit.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("IOServiceMatching");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * CFMutableDictionaryRef IOServiceMatching(const char *name)
     * }
     */
    public static FunctionDescriptor IOServiceMatching$descriptor() {
        return IOServiceMatching.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * CFMutableDictionaryRef IOServiceMatching(const char *name)
     * }
     */
    public static MethodHandle IOServiceMatching$handle() {
        return IOServiceMatching.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * CFMutableDictionaryRef IOServiceMatching(const char *name)
     * }
     */
    public static MemorySegment IOServiceMatching$address() {
        return IOServiceMatching.ADDR;
    }

    /**
     * {@snippet lang=c :
     * CFMutableDictionaryRef IOServiceMatching(const char *name)
     * }
     */
    public static MemorySegment IOServiceMatching(MemorySegment name) {
        var mh$ = IOServiceMatching.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IOServiceMatching", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IOCreatePlugInInterfaceForService {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            IOKit.C_INT,
            IOKit.C_INT,
            IOKit.C_POINTER,
            IOKit.C_POINTER,
            IOKit.C_POINTER,
            IOKit.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("IOCreatePlugInInterfaceForService");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * kern_return_t IOCreatePlugInInterfaceForService(io_service_t service, CFUUIDRef pluginType, CFUUIDRef interfaceType, IOCFPlugInInterface ***theInterface, SInt32 *theScore)
     * }
     */
    public static FunctionDescriptor IOCreatePlugInInterfaceForService$descriptor() {
        return IOCreatePlugInInterfaceForService.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * kern_return_t IOCreatePlugInInterfaceForService(io_service_t service, CFUUIDRef pluginType, CFUUIDRef interfaceType, IOCFPlugInInterface ***theInterface, SInt32 *theScore)
     * }
     */
    public static MethodHandle IOCreatePlugInInterfaceForService$handle() {
        return IOCreatePlugInInterfaceForService.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * kern_return_t IOCreatePlugInInterfaceForService(io_service_t service, CFUUIDRef pluginType, CFUUIDRef interfaceType, IOCFPlugInInterface ***theInterface, SInt32 *theScore)
     * }
     */
    public static MemorySegment IOCreatePlugInInterfaceForService$address() {
        return IOCreatePlugInInterfaceForService.ADDR;
    }

    /**
     * {@snippet lang=c :
     * kern_return_t IOCreatePlugInInterfaceForService(io_service_t service, CFUUIDRef pluginType, CFUUIDRef interfaceType, IOCFPlugInInterface ***theInterface, SInt32 *theScore)
     * }
     */
    public static int IOCreatePlugInInterfaceForService(int service, MemorySegment pluginType, MemorySegment interfaceType, MemorySegment theInterface, MemorySegment theScore) {
        var mh$ = IOCreatePlugInInterfaceForService.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IOCreatePlugInInterfaceForService", service, pluginType, interfaceType, theInterface, theScore);
            }
            return (int)mh$.invokeExact(service, pluginType, interfaceType, theInterface, theScore);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int kIOReturnExclusiveAccess = (int)-536870203L;
    /**
     * {@snippet lang=c :
     * #define kIOReturnExclusiveAccess -536870203
     * }
     */
    public static int kIOReturnExclusiveAccess() {
        return kIOReturnExclusiveAccess;
    }
    private static final int kIOReturnAborted = (int)-536870165L;
    /**
     * {@snippet lang=c :
     * #define kIOReturnAborted -536870165
     * }
     */
    public static int kIOReturnAborted() {
        return kIOReturnAborted;
    }
    private static final int kIOUSBPipeStalled = (int)-536854449L;
    /**
     * {@snippet lang=c :
     * #define kIOUSBPipeStalled -536854449
     * }
     */
    public static int kIOUSBPipeStalled() {
        return kIOUSBPipeStalled;
    }
    private static final int kIOUSBTransactionTimeout = (int)-536854447L;
    /**
     * {@snippet lang=c :
     * #define kIOUSBTransactionTimeout -536854447
     * }
     */
    public static int kIOUSBTransactionTimeout() {
        return kIOUSBTransactionTimeout;
    }
    /**
     * {@snippet lang=c :
     * #define kIOFirstMatchNotification "IOServiceFirstMatch"
     * }
     */
    public static MemorySegment kIOFirstMatchNotification() {
        class Holder {
            static final MemorySegment kIOFirstMatchNotification
                = IOKit.LIBRARY_ARENA.allocateFrom("IOServiceFirstMatch");
        }
        return Holder.kIOFirstMatchNotification;
    }
    /**
     * {@snippet lang=c :
     * #define kIOTerminatedNotification "IOServiceTerminate"
     * }
     */
    public static MemorySegment kIOTerminatedNotification() {
        class Holder {
            static final MemorySegment kIOTerminatedNotification
                = IOKit.LIBRARY_ARENA.allocateFrom("IOServiceTerminate");
        }
        return Holder.kIOTerminatedNotification;
    }
    /**
     * {@snippet lang=c :
     * #define kIOUSBDeviceClassName "IOUSBDevice"
     * }
     */
    public static MemorySegment kIOUSBDeviceClassName() {
        class Holder {
            static final MemorySegment kIOUSBDeviceClassName
                = IOKit.LIBRARY_ARENA.allocateFrom("IOUSBDevice");
        }
        return Holder.kIOUSBDeviceClassName;
    }
}

