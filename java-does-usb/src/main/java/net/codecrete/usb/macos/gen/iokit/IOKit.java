// Generated by jextract

package net.codecrete.usb.macos.gen.iokit;

import java.lang.foreign.AddressLayout;
import java.lang.foreign.MemoryLayout;
import java.lang.foreign.MemorySegment;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;

import static java.lang.foreign.ValueLayout.*;
public class IOKit  {

    public static final OfByte C_CHAR = JAVA_BYTE;
    public static final OfShort C_SHORT = JAVA_SHORT;
    public static final OfInt C_INT = JAVA_INT;
    public static final OfLong C_LONG = JAVA_LONG;
    public static final OfLong C_LONG_LONG = JAVA_LONG;
    public static final OfFloat C_FLOAT = JAVA_FLOAT;
    public static final OfDouble C_DOUBLE = JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = RuntimeHelper.POINTER;
    /**
     * {@snippet :
     * enum .kIOUSBFindInterfaceDontCare = 65535;
     * }
     */
    public static int kIOUSBFindInterfaceDontCare() {
        return (int)65535L;
    }
    /**
     * {@snippet :
     * enum .kUSBReEnumerateCaptureDeviceMask = 1073741824;
     * }
     */
    public static int kUSBReEnumerateCaptureDeviceMask() {
        return (int)1073741824L;
    }
    /**
     * {@snippet :
     * enum .kUSBReEnumerateReleaseDeviceMask = 536870912;
     * }
     */
    public static int kUSBReEnumerateReleaseDeviceMask() {
        return (int)536870912L;
    }
    public static MemoryLayout kCFRunLoopDefaultMode$LAYOUT() {
        return RuntimeHelper.POINTER;
    }
    public static VarHandle kCFRunLoopDefaultMode$VH() {
        return constants$2.const$1;
    }
    public static MemorySegment kCFRunLoopDefaultMode$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$2.const$2,"kCFRunLoopDefaultMode");
    }
    /**
     * Getter for variable:
     * {@snippet :
     * const CFRunLoopMode kCFRunLoopDefaultMode;
     * }
     */
    public static MemorySegment kCFRunLoopDefaultMode$get() {
        return (java.lang.foreign.MemorySegment) constants$2.const$1.get(RuntimeHelper.requireNonNull(constants$2.const$2, "kCFRunLoopDefaultMode"));
    }
    /**
     * Setter for variable:
     * {@snippet :
     * const CFRunLoopMode kCFRunLoopDefaultMode;
     * }
     */
    public static void kCFRunLoopDefaultMode$set(MemorySegment x) {
        constants$2.const$1.set(RuntimeHelper.requireNonNull(constants$2.const$2, "kCFRunLoopDefaultMode"), x);
    }
    public static MemoryLayout kIOMasterPortDefault$LAYOUT() {
        return JAVA_INT;
    }
    public static VarHandle kIOMasterPortDefault$VH() {
        return constants$2.const$3;
    }
    public static MemorySegment kIOMasterPortDefault$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$2.const$4,"kIOMasterPortDefault");
    }
    /**
     * Getter for variable:
     * {@snippet :
     * const mach_port_t kIOMasterPortDefault;
     * }
     */
    public static int kIOMasterPortDefault$get() {
        return (int) constants$2.const$3.get(RuntimeHelper.requireNonNull(constants$2.const$4, "kIOMasterPortDefault"));
    }
    /**
     * Setter for variable:
     * {@snippet :
     * const mach_port_t kIOMasterPortDefault;
     * }
     */
    public static void kIOMasterPortDefault$set(int x) {
        constants$2.const$3.set(RuntimeHelper.requireNonNull(constants$2.const$4, "kIOMasterPortDefault"), x);
    }
    public static MethodHandle IONotificationPortCreate$MH() {
        return RuntimeHelper.requireNonNull(constants$2.const$6,"IONotificationPortCreate");
    }
    /**
     * {@snippet :
     * IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort);
     * }
     */
    public static MemorySegment IONotificationPortCreate(int mainPort) {
        var mh$ = IONotificationPortCreate$MH();
        try {
            return (java.lang.foreign.MemorySegment)mh$.invokeExact(mainPort);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle IONotificationPortGetRunLoopSource$MH() {
        return RuntimeHelper.requireNonNull(constants$3.const$1,"IONotificationPortGetRunLoopSource");
    }
    /**
     * {@snippet :
     * CFRunLoopSourceRef IONotificationPortGetRunLoopSource(IONotificationPortRef notify);
     * }
     */
    public static MemorySegment IONotificationPortGetRunLoopSource(MemorySegment notify) {
        var mh$ = IONotificationPortGetRunLoopSource$MH();
        try {
            return (java.lang.foreign.MemorySegment)mh$.invokeExact(notify);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle IOObjectRelease$MH() {
        return RuntimeHelper.requireNonNull(constants$3.const$3,"IOObjectRelease");
    }
    /**
     * {@snippet :
     * kern_return_t IOObjectRelease(io_object_t object);
     * }
     */
    public static int IOObjectRelease(int object) {
        var mh$ = IOObjectRelease$MH();
        try {
            return (int)mh$.invokeExact(object);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle IOIteratorNext$MH() {
        return RuntimeHelper.requireNonNull(constants$3.const$4,"IOIteratorNext");
    }
    /**
     * {@snippet :
     * io_object_t IOIteratorNext(io_iterator_t iterator);
     * }
     */
    public static int IOIteratorNext(int iterator) {
        var mh$ = IOIteratorNext$MH();
        try {
            return (int)mh$.invokeExact(iterator);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle IOServiceAddMatchingNotification$MH() {
        return RuntimeHelper.requireNonNull(constants$3.const$6,"IOServiceAddMatchingNotification");
    }
    /**
     * {@snippet :
     * kern_return_t IOServiceAddMatchingNotification(IONotificationPortRef notifyPort, const io_name_t notificationType, CFDictionaryRef matching, IOServiceMatchingCallback callback, void* refCon, io_iterator_t* notification);
     * }
     */
    public static int IOServiceAddMatchingNotification(MemorySegment notifyPort, MemorySegment notificationType, MemorySegment matching, MemorySegment callback, MemorySegment refCon, MemorySegment notification) {
        var mh$ = IOServiceAddMatchingNotification$MH();
        try {
            return (int)mh$.invokeExact(notifyPort, notificationType, matching, callback, refCon, notification);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle IORegistryEntryGetRegistryEntryID$MH() {
        return RuntimeHelper.requireNonNull(constants$4.const$1,"IORegistryEntryGetRegistryEntryID");
    }
    /**
     * {@snippet :
     * kern_return_t IORegistryEntryGetRegistryEntryID(io_registry_entry_t entry, uint64_t* entryID);
     * }
     */
    public static int IORegistryEntryGetRegistryEntryID(int entry, MemorySegment entryID) {
        var mh$ = IORegistryEntryGetRegistryEntryID$MH();
        try {
            return (int)mh$.invokeExact(entry, entryID);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle IORegistryEntryCreateCFProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$4.const$3,"IORegistryEntryCreateCFProperty");
    }
    /**
     * {@snippet :
     * CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options);
     * }
     */
    public static MemorySegment IORegistryEntryCreateCFProperty(int entry, MemorySegment key, MemorySegment allocator, int options) {
        var mh$ = IORegistryEntryCreateCFProperty$MH();
        try {
            return (java.lang.foreign.MemorySegment)mh$.invokeExact(entry, key, allocator, options);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle IOServiceMatching$MH() {
        return RuntimeHelper.requireNonNull(constants$4.const$4,"IOServiceMatching");
    }
    /**
     * {@snippet :
     * CFMutableDictionaryRef IOServiceMatching(char* name);
     * }
     */
    public static MemorySegment IOServiceMatching(MemorySegment name) {
        var mh$ = IOServiceMatching$MH();
        try {
            return (java.lang.foreign.MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle IOCreatePlugInInterfaceForService$MH() {
        return RuntimeHelper.requireNonNull(constants$43.const$5,"IOCreatePlugInInterfaceForService");
    }
    /**
     * {@snippet :
     * kern_return_t IOCreatePlugInInterfaceForService(io_service_t service, CFUUIDRef pluginType, CFUUIDRef interfaceType, IOCFPlugInInterface*** theInterface, SInt32* theScore);
     * }
     */
    public static int IOCreatePlugInInterfaceForService(int service, MemorySegment pluginType, MemorySegment interfaceType, MemorySegment theInterface, MemorySegment theScore) {
        var mh$ = IOCreatePlugInInterfaceForService$MH();
        try {
            return (int)mh$.invokeExact(service, pluginType, interfaceType, theInterface, theScore);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet :
     * #define kIOReturnExclusiveAccess -536870203
     * }
     */
    public static int kIOReturnExclusiveAccess() {
        return (int)-536870203L;
    }
    /**
     * {@snippet :
     * #define kIOReturnAborted -536870165
     * }
     */
    public static int kIOReturnAborted() {
        return (int)-536870165L;
    }
    /**
     * {@snippet :
     * #define kIOUSBPipeStalled -536854449
     * }
     */
    public static int kIOUSBPipeStalled() {
        return (int)-536854449L;
    }
    /**
     * {@snippet :
     * #define kIOUSBTransactionTimeout -536854447
     * }
     */
    public static int kIOUSBTransactionTimeout() {
        return (int)-536854447L;
    }
    /**
     * {@snippet :
     * #define kIOFirstMatchNotification "IOServiceFirstMatch"
     * }
     */
    public static MemorySegment kIOFirstMatchNotification() {
        return constants$44.const$0;
    }
    /**
     * {@snippet :
     * #define kIOTerminatedNotification "IOServiceTerminate"
     * }
     */
    public static MemorySegment kIOTerminatedNotification() {
        return constants$44.const$1;
    }
    /**
     * {@snippet :
     * #define kIOUSBDeviceClassName "IOUSBDevice"
     * }
     */
    public static MemorySegment kIOUSBDeviceClassName() {
        return constants$44.const$2;
    }
}


